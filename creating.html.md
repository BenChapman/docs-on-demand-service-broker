---
title: On-demand Service Broker Documentation
owner: London Services Enablement
---

# Creating the Service Author Deliverables

- [What is required of the Service Authors?](#what-is-required-of-the-service-authors)
- [Creating a Service Release](#creating-a-service-release)
- [Creating a Service Adapter](#creating-a-service-adapter)
  - [Handling errors](#handling-errors)
- [Configuring manifest generation](#configuring-manifest-generation)
  - [Arbitrary parameters](#arbitrary-parameters)
  - [Previous manifest properties](#previous-manifest-properties)
  - [Service plan properties](#service-plan-properties)
  - [Order of precedence](#order-of-precedence)
- [Service adapter interface](#service-adapter-interface)
- [Subcommands](#sub-commands)
  - [generate-manifest](#generate-manifest)
     - [Output](#generate-manifest-output)
     - [service-deployment](#service-deployment)
     - [plan](#plan)
     - [arbitrary parameters](#arbitrary-parameters)
     - [previous manifest](#previous-manifest)
  - [create-binding](#create-binding)
     - [Output](#create-binding-output)
     - [binding-ID](#create-binding-id)
     - [bosh-VMs-JSON](#create-bosh-vms-json)
     - [manifest](#create-binding-manifest)
  - [delete-binding](#delete-binding)
     - [Output](#delete-binding-output)
     - [binding-ID](#delete-binding-id)
     - [bosh-VMs-JSON](#delete-binding-vm-json)
     - [manifest](#delete-binding-manifest)
- [Packaging](#packaging)
- [Golang SDK](#sdk)

<a id="what-is-required-of-the-service-authors"></a>
## What is required of the Service Authors?
The following deliverables are required from the service authors:

- Service release(s)
- BOSH release(s) to be deployed by the manifest that is generated by the Service Adapter
- Service Adapter BOSH release
- Contains the Service Adapter CLI
- Documentation for the operator to configure plan definitions for the Service Adapter

For information about what is required of the Operator, see [Responsibilities of the Operator](/on-demand-service-broker/operating.html#responsibility-of-the-operator).

<a id="creating-a-service-release"></a>
## Creating a Service Release

A service release is a BOSH release that is deployed at instance creation time, once for each service instance, by the On-demand Service Broker (ODB). We have created two examples:
  * [Redis](https://github.com/pivotal-cf-experimental/redis-example-service-release)
  * [Kafka](https://github.com/pivotal-cf-experimental/kafka-example-service-release)

See the [BOSH docs](http://bosh.io/docs) for help creating a BOSH release. We recommend creating sample manifests that deploy the service release(s), as this will help you write the `generate-manifest` component of the Service Adapter later.

### Job links
When generating a manifest, we recommend not using static IPs as this makes network IP management very complex. Instead, we recommend using [BOSH's job links feature](https://bosh.io/docs/links.html).
There are two types of job links, implicit and explicit. The [example Kafka release](https://github.com/pivotal-cf-experimental/kafka-example-service-release/blob/master/jobs/kafka_broker/spec#L15) uses implicit job links to get the IPs of the brokers and the zookeeper. Details on how to use the links feature are available [here](https://bosh.io/docs/links.html).

<a id="creating-a-service-adapter"></a>
## Creating a Service Adapter

A Service Adapter is an executable invoked by ODB. It is expected to respond to three subcommands:

- `generate-manifest`
  Generate a BOSH manifest for your service instance deployment and output to stdout as YAML, given information about the:
  - BOSH director (stemcells, release names)
  - service instance (ID, arbitrary parameters, plan properties, IAAS resources)
  - previous manifest, if this is an upgrade deployment

- `create-binding`
  Create (unique, if possible) credentials for the service instance, printing them to stdout as JSON.

- `delete-binding`
  Invalidate the created credentials, if possible. Some services (e.g. Redis) are single-user, and this endpoint will do nothing.

The parameters, and expected output from these subcommands will be explained in detail below. For each of these subcommands, exit status 0 indicates that the command succeeded, and any non-zero status indicates failure.

<a id="handling-errors"></a>
### Handling errors
If a subcommand fails, the adapter must return a non-zero exit status and an error, and may optionally print to stdout and/or stderr. The error message, along with the stdout and stderr streams will be printed in the broker log.

See an example implementation [here](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/bb5094efdd7c5e230ecade88d68eda131ef1a8a2/adapter/create_binding.go#L26-28).

<a id="configuring-manifest-generation"></a>
## Configuring manifest generation

<a id="arbitrary-parameters"></a>
### Arbitrary parameters

Service authors can choose to allow Cloud Foundry users to configure service instances with arbitrary parameters. See the PCF docs on [Managing Service Instances with the CLI](https://docs.pivotal.io/pivotalcf/devguide/services/managing-services.html). Arbitrary parameters can be passed to the service adapter when creating, or updating a service instance. They allow Cloud Foundry users to override the default configuration for a service plan.

Service authors must document the usage of arbitrary parameters for Cloud Foundry users.

Note: we recommend that arbitrary parameters are recorded in the service instance manifest, so that they can be migrated in subsequent deployments.

For example:

- the [Kafka service adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go) supports the `auto_create_topics` arbitrary parameter to configure auto-creation of topics on the cluster.

<a id="previous-manifest-properties"></a>
### Previous manifest properties

Service authors can choose to migrate certain properties for the service from the previous manifest when updating a service instance. If the previous manifest is ignored then any properties configured using arbitrary parameters will not be migrated when a service instance is updated.

Service authors must document the migration of previous manifest properties for operators.

For example:

- the [Kafka service adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go) supports migration of the `auto_create_topics` previous plan property to configure auto-creation of topics on the cluster.

<a id="service-plan-properties"></a>
### Service plan properties

Service authors can choose to support certain properties for the service in the adapter code. These properties are service-specific traits used to customize the service. They do not necessarily map to jobs one to one; a plan property may affect multiple jobs in the deployment. Plan properties are a mechanism for the operator to define different plans.

Service authors must document the usage of plan properties for the operator.

For example:

- the [Redis service adapter](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/master/adapter/redis_service_adapter.go) supports the `persistent` property which can be used to attach a disk to the vm.
- the [Kafka service adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go) supports the `auto_create_topics` property to enable auto-creation of topics on the cluster.

<a id="order-of-precedence"></a>
### Order of precedence

Note, we recommend service authors use the following order of precedence in their service adapters when generating manifests:

1. arbitrary parameters
1. previous manifest properties
1. plan properties

For example, see `auto_create_topics` in the [example Kafka service adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/adapter/generate_manifest.go).

<a id="service-adapter-interface"></a>
## Service adapter interface
A service adapter is expected to be implemented as a binary with the interface

```
service-adapter [subcommand] [params ...]
```

where the subcommand can be generate-manifest, create-binding, delete-binding

Examples are provided for [Redis](https://github.com/pivotal-cf-experimental/redis-example-service-adapter) and [Kafka](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter). Note that these Golang examples us the SDK to help with cross-cutting concerns such as unmarshalling the JSON command line parameters. For example, see the use of `CommandLineHelper` in the [redis-adapter](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/master/cmd/service-adapter/main.go#L14).
<a id="sub-commands"></a>
## Subcommands
<a id="generate-manifest"></a>
### generate-manifest

```
service-adapter generate-manifest [service-deployment-JSON] [plan-JSON] [arbitrary-params-JSON] [previous-manifest-YAML]
```

The generate-manifest subcommand takes in 4 arguments and returns a BOSH deployment manifest YAML.

<a id="generate-manifest-output"></a>
#### Output

If the `generate-manifest` command is successful, it should return an exit code of 0 and print the BOSH manifest YAML to stdout. If the command failed, it should return any non-zero exit code. Stdout and stderr from the command will be logged by the ODB.

<a id="service-deployment"></a>
#### service-deployment
Provides information regarding the bosh director

| field                     |       Type        |                                                            Description |
|:--------------------------|:-----------------:|-----------------------------------------------------------------------:|
| deployment_name           |      string       |                                 name of the deployment on the director |
| releases                  | array of releases | list of service releases configured for the deployment by the operator |
| release.name              |      string       |                                    name of the release on the director |
| release.version           |      string       |                                                 version of the release |
| release.jobs              | array of strings  |                                 list of jobs required from the release |
| stemcell                  |        map        |                                 the stemcell available on the director |
| stemcell.stemcell_os      |      string       |                                  stemcell OS available on the director |
| stemcell.stemcell_version |      string       |                             stemcell version available on the director |

For example

```json
{
    "deployment_name": "service-instance_$GUID",
    "releases": [{
        "name": "kafka",
        "version": "dev.42",
        "jobs": [
            "kafka_node",
            "zookeeper"
        ]
    }],
    "stemcell": {
        "stemcell_os": "BeOS",
        "stemcell_version": "2"
    }
}
```

ODB only supports injecting one stemcell into each service deployment (different instance groups cannot have different stemcells).

Your Service Adapter should be opinionated about which jobs it requires to generate its manifest. For example, the Kafka example requires `kafka_node` and `zookeeper`. It should not be opinionated about the mapping of BOSH release to job. The jobs can all be provided by one release, or across many. [Here](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/deploymentinstancegroups/deployment_instance_groups.go) is an example of mapping the service releases parameter to a BOSH manifest `releases` and `instance_groups` sections.

You should provide documentation about which jobs are required by your Service Adapter, and which BOSH releases operators should get these jobs from.

<a id="plan"></a>
#### plan
Plan for which the manifest is supposed to be generated

| field                                 |           Type           |                                                                                                                            Description |
|:--------------------------------------|:------------------------:|---------------------------------------------------------------------------------------------------------------------------------------:|
| instance_groups                       | array of instance groups |                                                                                                instance groups configured for the plan |
| instance_group.name                   |          string          |                                                                                                             name of the instance group |
| instance_group.vm\_type               |          string          |                                         the vm_type configured for the instance group, matches one in the cloud config on the director |
| instance_group.persistent\_disk\_type |          string          |                            the persistent_disk_type configured for the instance group, matches one in the cloud config on the director |
| instance_group.networks               |     array of strings     |                                                                                   the networks the instance group is supposed to be in |
| instance_group.instances              |           int            |                                                                                             number of instances for the instance group |
| instance_group.lifecycle              |          string          | Optional, specifies the kind of workload the instance group represents. Valid values are `service` and `errand`; defaults to `service` |
| instance_group.azs                    |     array of strings     |                                                         a list of availability zones that the instance groups should be striped across |
| properties                            |           map            |                                             properties with which the operator has configured the instance group, for the current plan |

For example

```json
{
   "instance_groups":[
      {
         "name":"example-server",
         "vm_type":"small",
         "persistent_disk_type":"ten",
         "networks":[
            "example-network"
         ],
         "azs":[
            "example-az"
         ],
         "instances":1
      },
      {
         "name":"example-migrations",
         "vm_type":"small",
         "persistent_disk_type":"ten",
         "networks":[
            "example-network"
         ],
         "instances":1,
         "lifecycle": "errand"
      }
   ],
   "properties":{
      "example":"property"
   }
}
```

Plans are composed by the operator and consist of properties and resource mappings:

* **Properties**

  Properties are service-specific parameters chosen by the service author. The Redis example exposes a property `persistence`, which takes a boolean value and toggles disk persistence for Redis. These should be documented by the service developers for the operator.

* **Resource mappings**

  The `instance_groups` section of the plan JSON. This maps service deployment instance groups (defined by the service author) to resources (defined by the operator). The service developers should document the list of instance group names required for their deployment (e.g. "redis-server") and any constraints they recommend on resources (e.g. operator must add a persistent disk if persistence property is enabled). These constraints can of course be enforced in code. The `instance_groups` section also contains a field for `lifecycle`, which can be set by the operator. The service adapter will add a lifecycle field to the instance group within the bosh manifest when specified.

<a id="arbitrary-parameters"></a>
#### arbitrary parameters
This is a JSON object with arbitrary keys and values which were passed by the application developer as a `cf` CLI parameter when creating, or updating the service instance.

Note: when updating existing service instances, any arbitrary parameters passed on a previous create or update will not be passed again. Therefore, for arbitrary parameters to stay the same across multiple deployments they must be retrieved from the previous manifest.

<a id="previous-manifest"></a>
#### previous manifest
The previous manifest as YAML. The previous manifest is nil if this is a new deployment. The format of the manifest should match the [bosh v2 manifest](https://bosh.io/docs/manifest-v2.html).

It is up to the service author to perform any necessary service-specific migration logic here, if previous manifest is non-nil.

Another use-case of the previous manifest is for the migration of deployment properties which need to stay the same across multiple deployments of a manifest. For example in the Redis example, we [generate a password](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/master/adapter/redis_service_adapter.go#L322) when we do a new deployment. But when the previous deployment manifest is provided, we copy the password over from [the previous deployment](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/master/adapter/redis_service_adapter.go#L320), as generating a new password for existing deployments will break existing bindings.

For example see the [example Redis service adapter](https://github.com/pivotal-cf-experimental/redis-example-service-adapter/blob/master/adapter/redis_service_adapter.go#L318-L323).

<a id="generate-manifest-output"></a>

---

<a id="create-binding"></a>
### create-binding

```
service-adapter create-binding [binding-ID] [bosh-VMs-JSON] [manifest-YAML] [arbitrary-parameters]
```

Binding credentials for a service instance should share a namespace, and should be unique if possible. E.g. for MySQL, two bindings could include a different username/password pairs, but share the same MySQL database tables and data. The first step is to determine which credentials are best to supply in the context of your service. We recommend that users can be identified statelessly from the binding ID, and the simplest way to do this is to name the user after the binding ID.

Note that at this time ODB does not support syslog drains or route services, so bindings are only a map of credentials.
<a id="create-binding-output"></a>

#### Output

If the `create-binding` command is successful, it should return an exit code of 0 and print the arbitrary credentials JSON on stdout. If the command failed, it should return any non-zero exit code. Stdout and stderr from the command will be logged by the ODB.

<a id="create-binding-id"></a>
#### binding-ID
The binding-ID generated by the Cloud Controller.

<a id="create-bosh-vms-json"></a>
#### bosh-VMs-JSON
A map of instance group name to an array of IPs provisioned for that instance group.

For example

```json
{
  "mysql_node": ["10.0.0.1", "10.0.0.2", "10.0.0.3"],
  "management_box": ["10.0.0.4"]
}
```

This can be used to connect to the instance deployment if required, to create a service specific binding. In the example above, the Service Adapter may connect to MySQL as the admin and create a user. As part of the binding, the `mysql_node` IPs would be returned, but maybe not the `management_box`.

<a id="create-binding-manifest"></a>
#### manifest
The current manifest as YAML. This is used to extract information about the deployment that is necessary for the binding (e.g. admin credentials with which to create users). The format of the manifest should match the [bosh v2 manifest](https://bosh.io/docs/manifest-v2.html)

#### arbitrary-params

This is a JSON object with arbitrary keys and values which were passed by the application developer as a `cf` CLI parameter when binding to a service.
For example see the [kafka create binding](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/cmd/service-adapter/main.go#L61)


#### Credentials for bindings

We have identified three approaches to credentials for a service binding.

##### 1. Static credentials

In this case, the same credentials are used for all bindings. One option is to define these credentials in the service instance manifest.

This scenario makes sense for services that use the same credentials for all bindings, such as Redis. For example:

```yaml
properties:
  redis:
    password: <same-for-all-bindings>
```

##### 2. Credentials unique to each binding

In this case, when the adapter `generate-manifest` subcommand is invoked, it generates random admin credentials and returns them as part of the service instance manifest. When the `create-binding` subcommand is invoked, the adapter can use the admin credentials from the manifest to create unique credentials for the binding. Subsequent `create-binding`s create new credentials.

This option makes sense for services whose binding creation resembles user creation, such as MySQL or RabbitMQ. For example, in MySQL the admin user can be used to create a new user and database for the binding:

```yaml
properties:
  admin_password: <use-to-create-credentials>
```

##### 3. Using an agent

In this case, the author defines an agent responsible for handling creation of credentials unique to each binding. The agent must be added as a BOSH release in the service manifest. Moreover, the service and agent jobs should be co-located in the same instance group.

This option is useful for services where the adapter cannot or prefers not to directly call out to the service instance, and instead delegates responsibility for setting up new credentials to an agent.

For example:

```yaml
releases:
  - name: service-release
    version: latest
  - name: credentials-agent-release
    version: latest

instance_groups:
  - name: service-group
    jobs:
      - name: service-job
        release: service-release
      - name: credentials-agent-job
        release: credentials-agent-release
```

---

<a id="delete-binding"></a>
### delete-binding

```
service-adapter delete-binding [binding-ID] [bosh-VMs-JSON] [manifest-YAML]
```

This should invalidate the credentials that were generated by `create-binding` if possible. E.g. for MySQL, it would delete the binding user.

<a id="delete-binding-output"></a>
#### Output

If the `delete-binding` command is successful, it should output a exit code of 0. No other output is required. If the command failed, it should return any non-zero exit code. Stdout and stderr from the command will be logged by the ODB.

<a id="delete-binding-id"></a>
#### binding-ID
The binding to be deleted.

<a id="delete-binding-vm-json"></a>
#### bosh-VMs-JSON
A map of instance group name to an array of IPs provisioned for that instance group.

For example

For example

```json
{
  "my-instance-group": ["10.0.0.1", "10.0.0.2", "10.0.0.3"]
}
```

This can be used to connect to the actual VMs if required, to delete a service specific binding. For example delete a user in MySQL.

<a id="delete-binding-manifest"></a>
#### manifest
The current manifest as YAML. This is used to extract information about the deployment that is necessary for the binding (e.g. credentials). The format of the manifest should match the [bosh v2 manifest](https://bosh.io/docs/manifest-v2.html)

For example see the [kafka delete binding](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/master/cmd/service-adapter/main.go#L73)

<a id="packaging"></a>
## Packaging
The adapter should be packaged as a BOSH release, which should be co-located with the ODB release in a BOSH manifest by the operator. This is only done in order to place the adapter executable on the same VM as the ODB server, therefore the adapter BOSH job's `monit` file should probably have no processes defined.

Example service adapter releases:
- [kafka](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter-release)
- [redis](https://github.com/pivotal-cf-experimental/redis-example-service-adapter-release)

<a id="sdk"></a>
## Golang SDK

We have published a [SDK](https://github.com/pivotal-cf/on-demand-service-broker-sdk) for teams writing their service adapters in Golang. It encapsulates the command line invocation handling, parameter parsing and response serialization so the adapter authors can focus on the service specific bits in the adapter.

For the generated BOSH manifest the SDK supports properties in two levels: manifest (global) and job level. Global properties are [deprecated in BOSH](http://bosh.io/docs/manifest-v2.html#properties), in favour of job level properties and job links. As an example, refer to the [Kafka example service adapter property generation](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter/blob/c4cc3682a1e7c492883b064f8faf3a8d10fd1849/adapter/generate_manifest.go#L72-101).

To use the adapter, the author should create an struct, conforming to the interface:

```go
type ServiceAdapter interface {
	GenerateManifest(serviceDeployment ServiceDeployment, plan Plan, arbitraryParams map[string]interface{}, previousManifest *bosh.BoshManifest) (bosh.BoshManifest, error)
	CreateBinding(bindingID string, deploymentTopology bosh.BoshVMs, manifest bosh.BoshManifest) (map[string]interface{}, error)
	DeleteBinding(bindingID string, deploymentTopology bosh.BoshVMs, manifest bosh.BoshManifest) error
}
```

In the main function for the adapter, the author call the `HandleCommandLineInvocation` function, with the adapter object

```go
package main

import (
	"log"
	"os"

	"github.com/bar-org/foo-service-adapter/adapter"
	"github.com/pivotal-cf/on-demand-service-broker-sdk/serviceadapter"
)

func main() {
	logger := log.New(os.Stderr, "[foo-service-adapter] ", log.LstdFlags)
	serviceAdapter := adapter.Adapter{}
	serviceadapter.HandleCommandLineInvocation(os.Args, serviceAdapter, logger)
}
```

For more complete code examples please take a look at the [kafka adapter](https://github.com/pivotal-cf-experimental/kafka-example-service-adapter) or the [redis adapter](https://github.com/pivotal-cf-experimental/redis-example-service-adapter)

**[Back to Contents Page](/on-demand-service-broker/index.html)**
